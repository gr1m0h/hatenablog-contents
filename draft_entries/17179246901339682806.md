---
Title: 負荷テストツール「k6」入門
EditURL: https://blog.hatena.ne.jp/gr1m0h/gr1m0h.hatenablog.com/atom/entry/17179246901339682806
PreviewURL: https://gr1m0h.hatenablog.com/draft/entry/tg-hRSTc2GYUSCPlnCgHwz_oc_s
Draft: true
---

## はじめに

APIやWebアプリケーションのパフォーマンスを評価するために、負荷テストは欠かせません。また、インフラの**キャパシティプランニング**を実施するうえでも、負荷テストは欠かせない手法です。

キャパシティプランニングとは、予想される未来の需要に対して必要な可用性を提供できる十分なキャパシティと冗長性を保障する反復型のプロセスです。負荷テストを通じて現状構成のキャパシティを把握し、ボトルネックの特定やスケーラビリティ特性の把握を行うことで、要求されるパフォーマンスを満たす構成を算出できます。

k6は、JavaScriptやTypeScriptでテストスクリプトを記述でき、開発者にとって非常に扱いやすいツールです。

[https://k6.io/:embed:cite]

私は2018年頃からk6を負荷テストで利用しており、当時は公式ドキュメントへのコントリビュートも行っていました。当時の活動については、以下のブログ記事に記載しています。

[https://tech-blog.optim.co.jp/entry/2019/01/15/173000:embed:cite]

しかし、2025年5月にk6 1.0がリリースされ、ネイティブTypeScriptサポートやセマンティックバージョニングへの準拠など大きなアップデートがありました。そこで、最新状況を把握し知識をアップデートするために、改めてk6の基本から発展的な使い方までまとめ直すことにしました。

## k6とは

k6はGrafana Labs社が開発するオープンソースの負荷テストツールです。Go言語で実装されており、テストスクリプトはJavaScriptまたはTypeScriptで記述します。

k6には以下のような特徴があります。

- **軽量で高速**: VUはゴルーチンとして実行されるため、単一マシンでも大規模な負荷をかけられる
- **開発者フレンドリー**: JavaScript/TypeScriptで記述でき、Webエンジニアにとって学習コストが低い
- **豊富なプロトコル対応**: HTTP/HTTPS、WebSocket、gRPC、ブラウザテストなど幅広く対応
- **Grafana Cloudとの連携**: クラウドベースの「Grafana Cloud k6」でスケーラブルなテスト実行や結果の可視化が可能

2025年5月にリリースされたk6 1.0では、ネイティブTypeScriptサポート、セマンティックバージョニングへの準拠、ブラウザモジュールの正式リリースなど、大きなアップデートがありました。

詳細については以下のドキュメントを参照ください。

[https://grafana.com/docs/k6/latest/:embed:cite]

## k6の歴史

2018年頃にk6を利用していた当初からk6を取り巻く状況は大きく変わりました。部分的に把握している部分はありますが、歴史的なところについてもまとめてみようと思います。

この項は、歴史的なことにしか触れないので、興味のない方は読み飛ばしていただいて構いません。

k6はスウェーデンのLoad Impact社が2016年に開発を開始し、2017年2月にオープンソースとして公開したツールです。

k6が登場する前のLoad Impact社が提供するLoad ImpactというSaaSでは、スクリプト言語として**Lua**を使用していました。Load Impactの開発者ブログによると、LuaJIT VMは非常に高速でリソース効率が良く、限られたハードウェアで多くの仮想ユーザーをシミュレートできるため、負荷テストツールには適した選択だったとのことです。しかし、Luaは当時まだマイナーな言語であり、多くの開発者にとって馴染みがないという課題がありました。そこで、より多くの開発者が使いやすいJavaScriptを採用した新しいツールとしてk6が開発されました。つまり、k6自体は最初からJavaScriptベースで設計されており、k6でLuaを使うことはできません。

[https://web.archive.org/web/20240314164107/https://k6.io/blog/creating-k6/:embed:cite]

私が2018年頃に利用していた当時は、CLIツールとしてのk6と、クラウドサービスとしての「Load Impact」「Load Impact Insights」という構成でした。Load Impactはk6のスクリプトをクラウド上で分散実行でき、Load Impact Insightsで結果を可視化・分析できるサービスでした。当時はLuaベースのLoad Impact v3も並行して提供されており、LuaからJavaScriptへの移行ガイドも用意されていました。

2020年2月24日、Load Impact社は製品・ブランド名を「k6」にリブランディングし、クラウドサービスも「k6 Cloud」に名称変更しました。なお、法人名（Load Impact AB）は変更されていません。これは会社名の変更ではなく、あくまで製品・ブランド名のリブランディングです。

[https://community.grafana.com/t/load-impact-is-now-k6/95571:embed:cite]

そして2021年6月17日、GrafanaCONline 2021の最終日にGrafana LabsによるLoad Impact社の買収が発表されました。

[https://grafana.com/about/press/2021/06/17/grafana-labs-brings-modern-open-source-load-testing-to-observability-with-acquisition-of-k6/:embed:cite]

[https://www.globenewswire.com/en/news-release/2021/06/17/2249273/0/en/Grafana-Labs-Brings-Modern-Open-Source-Load-Testing-to-Observability-with-Acquisition-of-k6.html:embed:cite]

その後、k6 CloudはGrafana Cloudに統合され、現在は「Grafana Cloud k6」として提供されています。OSSとしてのk6の開発方針は変わらず、Grafanaのオブザーバビリティスタックとの統合が進み、より強力なツールへと進化しています。

2025年5月7日、GrafanaCON 2025にてk6 1.0の一般提供開始（GA）が発表されました。約9年間の開発を経て、ネイティブTypeScriptサポート、セマンティックバージョニング、安定したAPIサーフェスなど、エンタープライズ利用に耐えうる成熟したツールとなりました。

[https://grafana.com/about/press/2025/05/07/grafana-labs-demonstrates-open-source-leadership-at-grafanacon-2025/:embed:cite]

[https://grafana.com/blog/2025/05/07/grafana-k6-1.0-release/:embed:cite]

## インストール

macOSではHomebrewを使用してインストールできます。

```bash
brew install k6
```

Linuxの場合は、以下のコマンドでインストールします。

```bash
# Debian/Ubuntu
sudo gpg -k
sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6
```

Dockerを使用する場合は、以下のイメージを利用できます。

```bash
docker run --rm -i grafana/k6 run - <script.js
```

インストールが完了したら、バージョンを確認します。

```bash
k6 version
```

2026年1月時点ではk6 1.0以降のバージョンがインストールされることを確認してください。

## テストスクリプトの作成

k6はテストスクリプトのテンプレートを生成するコマンドを提供しています。以下のコマンドでテンプレートファイルを作成できます。

```bash
k6 new script.js
```

ファイル名を指定しない場合は`script.js`として作成されます。TypeScriptで記述したい場合は、拡張子を`.ts`に変更します。

```bash
k6 new script.ts
```

生成されるテンプレートは以下のような内容です。

```javascript
import http from "k6/http";
import { sleep } from "k6";

export const options = {
  vus: 10,
  duration: "30s",
};

export default function () {
  http.get("https://test.k6.io");
  sleep(1);
}
```

テストスクリプトは主に3つの部分で構成されています。

- **インポート**: k6の組み込みモジュールを読み込む
- **options**: テストの設定（VU数、実行時間、閾値など）を定義
- **default function**: 各VUが繰り返し実行するテストロジック

## TypeScriptでのテスト作成

k6 1.0からはTypeScriptがネイティブサポートされ、トランスパイルの設定なしで直接実行できるようになりました。以前のバージョンで必要だった`--compatibility-mode=experimental_enhanced`オプションは不要です。

TypeScriptでテストを記述する場合、型定義をインストールしておくと開発体験が向上します。

```bash
npm install --save-dev @types/k6
```

以下はTypeScriptで記述したテストスクリプトの例です。

```typescript
import http, { Response } from "k6/http";
import { check, sleep } from "k6";
import { Options } from "k6/options";

export const options: Options = {
  vus: 10,
  duration: "30s",
  thresholds: {
    http_req_duration: ["p(95)<500"],
    http_req_failed: ["rate<0.01"],
  },
};

interface ApiResponse {
  status: string;
  data: unknown;
}

export default function (): void {
  const res: Response = http.get("https://test.k6.io/public/crocodiles/1/");

  check(res, {
    "status is 200": (r) => r.status === 200,
    "response has data": (r) => {
      const body = r.json() as ApiResponse;
      return body !== null;
    },
  });

  sleep(1);
}
```

型安全性を活かすことで、リファクタリングの安全性やコードの可読性が向上します。

## テストの実行

テストの実行は`k6 run`コマンドで行います。

```bash
k6 run script.js
```

TypeScriptファイルの場合も同様です。

```bash
k6 run script.ts
```

実行すると、以下のような結果がターミナルに出力されます。

```
         /\      Grafana   /‾‾/
    /\  /  \     |\  __   /  /
   /  \/    \    | |/ /  /   ‾‾\
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/

     execution: local
        script: script.js
        output: -

     scenarios: (100.00%) 1 scenario, 10 max VUs, 1m0s max duration
              default: 10 looping VUs for 30s

     data_received..................: 1.2 MB 40 kB/s
     data_sent......................: 54 kB  1.8 kB/s
     http_req_blocked...............: avg=5.12ms  min=1µs     med=3µs     max=256.31ms p(90)=5µs     p(95)=6µs
     http_req_duration..............: avg=121.45ms min=112.34ms med=118.92ms max=189.45ms p(90)=135.67ms p(95)=145.23ms
     http_req_failed................: 0.00%  ✓ 0   ✗ 280
     iterations.....................: 280    9.333333/s
     vus............................: 10     min=10 max=10
     vus_max........................: 10     min=10 max=10
```

k6 1.0ではテスト終了時のサマリー表示が刷新され、より見やすくなっています。

## 負荷のかけ方

### 1. 固定負荷

最もシンプルな方法は、VU数と実行時間を固定する方法です。

```javascript
export const options = {
  vus: 10, // 仮想ユーザー数
  duration: "30s", // 実行時間
};
```

コマンドラインオプションでも指定できます。

```bash
k6 run --vus 10 --duration 30s script.js
```

### 2. 段階的負荷（stages）

実際のユーザーアクセスに近い負荷パターンをシミュレートするには、`stages`オプションを使用します。

```javascript
export const options = {
  stages: [
    { duration: "30s", target: 20 }, // 30秒かけてVUを20まで増加
    { duration: "1m", target: 20 }, // 1分間VU20を維持
    { duration: "30s", target: 0 }, // 30秒かけてVUを0まで減少
  ],
};
```

この設定により、ウォームアップ、定常状態、クールダウンという典型的な負荷パターンを再現できます。

### 3. シナリオ

より複雑な負荷パターンには`scenarios`オプションを使用します。シナリオを使うと、複数の負荷テストパターンを1つのスクリプトで管理できます。

```javascript
export const options = {
  scenarios: {
    // 一定レートでリクエストを送信
    constant_request_rate: {
      executor: "constant-arrival-rate",
      rate: 100,
      timeUnit: "1s",
      duration: "1m",
      preAllocatedVUs: 50,
    },
    // 段階的にVUを増加
    ramping_vus: {
      executor: "ramping-vus",
      startVUs: 0,
      stages: [
        { duration: "30s", target: 50 },
        { duration: "1m", target: 50 },
        { duration: "30s", target: 0 },
      ],
    },
  },
};
```

k6には複数のエグゼキュータが用意されており、目的に応じて選択できます。

- `shared-iterations`: 全VUで指定した回数のイテレーションを共有
- `per-vu-iterations`: 各VUが指定した回数のイテレーションを実行
- `constant-vus`: 一定数のVUで実行
- `ramping-vus`: VU数を段階的に変化
- `constant-arrival-rate`: 一定レートでイテレーションを開始
- `ramping-arrival-rate`: イテレーション開始レートを段階的に変化

## 閾値の設定

テストの合否判定には`thresholds`オプションを使用します。

```javascript
export const options = {
  thresholds: {
    http_req_duration: ["p(95)<500"], // 95%タイルが500ms未満
    http_req_failed: ["rate<0.01"], // エラー率が1%未満
  },
};
```

閾値を満たさない場合、k6は終了コード1で終了します。CI/CDパイプラインに組み込む際に便利です。

複数の条件を設定することもできます。

```javascript
export const options = {
  thresholds: {
    http_req_duration: [
      "p(95)<500", // 95%タイルが500ms未満
      "p(99)<1000", // 99%タイルが1000ms未満
      "avg<300", // 平均が300ms未満
    ],
    http_req_failed: ["rate<0.01"],
  },
};
```

## チェックとグループ

### チェック

`check`関数を使用して、レスポンスの検証を行います。

```javascript
import http from "k6/http";
import { check } from "k6";

export default function () {
  const res = http.get("https://test.k6.io/public/crocodiles/1/");

  check(res, {
    "status is 200": (r) => r.status === 200,
    "response time < 500ms": (r) => r.timings.duration < 500,
    "body contains id": (r) => r.body.includes("id"),
  });
}
```

チェックは閾値と異なり、失敗してもテストは継続されます。テスト結果のサマリーでチェックの成功率を確認できます。

### グループ

関連するリクエストをグループ化することで、結果の分析がしやすくなります。

```javascript
import http from "k6/http";
import { group, sleep } from "k6";

export default function () {
  group("ログインフロー", function () {
    http.get("https://test.k6.io/");
    http.post("https://test.k6.io/login", {
      username: "test_user",
      password: "password123",
    });
  });

  group("商品閲覧", function () {
    http.get("https://test.k6.io/products");
    http.get("https://test.k6.io/products/1");
  });

  sleep(1);
}
```

## テストライフサイクル

k6のテストには4つのフェーズがあります。

```javascript
// 1. init: 各VUで最初に1回実行される
const BASE_URL = "https://test.k6.io";

// 2. setup: テスト全体で最初に1回実行される
export function setup() {
  const res = http.post(`${BASE_URL}/auth/token`, {
    username: "admin",
    password: "password",
  });
  return { token: res.json("token") };
}

// 3. default: 各VUで繰り返し実行される（メインのテストロジック）
export default function (data) {
  const headers = { Authorization: `Bearer ${data.token}` };
  http.get(`${BASE_URL}/api/data`, { headers });
}

// 4. teardown: テスト全体の最後に1回実行される
export function teardown(data) {
  console.log("Test completed with token:", data.token);
}
```

`setup`で取得したデータは、`default`と`teardown`に引数として渡されます。この仕組みを活用することで、認証トークンの取得やテストデータの準備を効率的に行えます。

## 結果の可視化

### Web Dashboard

k6には組み込みのWebダッシュボードが用意されています。以下のコマンドで有効化できます。

```bash
k6 run --out web-dashboard script.js
```

実行中に`http://localhost:5665`にアクセスすると、リアルタイムで結果を確認できます。

### JSON/CSV出力

結果をファイルに出力することもできます。

```bash
# JSON形式で出力
k6 run --out json=results.json script.js

# CSV形式で出力
k6 run --out csv=results.csv script.js
```

### Grafana Cloudへの送信

Grafana Cloud k6を使用すると、クラウド上でテスト結果を可視化・分析できます。

```bash
k6 cloud run script.js
```

ローカルで実行しつつ結果をクラウドに送信する場合は、以下のコマンドを使用します。

```bash
k6 cloud run --local-execution script.js
```

## HARファイルからのテスト作成

ブラウザの開発者ツールで記録したHAR（HTTP Archive）ファイルからk6のテストスクリプトを生成できます。

```bash
# har-to-k6のインストール
npm install -g har-to-k6

# HARファイルからk6スクリプトを生成
har-to-k6 recording.har -o load-test.js
```

この方法を使うと、実際のユーザー操作を再現したテストスクリプトを素早く作成できます。

## さいごに

k6の基本的な使い方について紹介しました。k6 1.0のリリースにより、TypeScriptのネイティブサポートやセマンティックバージョニングへの準拠など、より安定した開発体験が得られるようになりました。

本記事ではローカルでの実行を中心に解説しましたが、Grafana Cloud k6を使用した分散負荷テストやCI/CDパイプラインへの統合など、発展的なトピックについても今後まとめたいと考えています。形になったタイミングで、ブログや登壇でお話しできればと思います。

詳細については以下のドキュメントを参照ください。

[https://grafana.com/docs/k6/latest/:embed:cite]

[https://github.com/grafana/k6:embed:cite]
