---
Title: k6による負荷テストの基本と実践
Date: 2026-01-14T13:26:30+09:00
URL: https://gr1m0h.hatenablog.com/entry/2026/01/14/132630
EditURL: https://blog.hatena.ne.jp/gr1m0h/gr1m0h.hatenablog.com/atom/entry/17179246901339682806
---

## はじめに

私は2018年からk6を負荷テストで利用しており、当時は公式ドキュメントへのコントリビュートも行っていました。当時の活動については、以下のブログ記事に記載しています。

[https://tech-blog.optim.co.jp/entry/2019/01/15/173000:embed:cite]

k6は、2025年5月に1.0がリリースされ、ネイティブTypescriptサポートやセマンティックバージョニングへの準拠など大きなアップデートがありました。そこで、最新状況を把握し知識をアップデートするために、改めてk6の基本から発展的な使い方までまとめ直すことにしました。

なお、本記事ではAPIやWebアプリケーションの負荷テストを想定しています。負荷テストはインフラのキャパシティプランニングにおいても欠かせません。

キャパシティプランニングとは、予想される未来の需要に対して必要な可用性を提供できる十分なキャパシティと冗長性を保障する反復型のプロセスです。負荷テストを通じて現状構成のキャパシティを把握し、ボトルネックの特定やスケーラビリティ特性の把握を行うことで、要求されるパフォーマンスを満たす構成を算出できます。

[https://k6.io/:embed:cite]

## k6とは

k6はGrafana Labs社が開発するオープンソースの負荷テストツールです。Goで実装されており、テストスクリプトはJavaScriptまたはTypeScriptで記述します。

k6には以下のような特徴があります。

- **軽量で高速**: VU（Virtual User）はゴルーチンとして実行されるため、単一マシンでも大規模な負荷をかけられる
- **開発者フレンドリー**: JavaScript/TypeScriptで記述でき、Webエンジニアにとって学習コストが低い
- **豊富なプロトコル対応**: HTTP/HTTPS、WebSocket、gRPC、ブラウザテストなど幅広く対応
- **Grafana Cloudとの連携**: クラウドベースの「Grafana Cloud k6」でスケーラブルなテスト実行や結果の可視化が可能

2025年5月にリリースされたk6 1.0では、ネイティブTypeScriptサポート、セマンティックバージョニングへの準拠、ブラウザモジュールの正式リリースなど、大きなアップデートがありました。

詳細については以下のドキュメントを参照ください。

[https://grafana.com/docs/k6/latest/:embed:cite]

## k6の歴史

2018年、私がk6を利用していた当初からk6を取り巻く状況は大きく変わりました。部分的に把握しているところはありますが、歴史的なところについて改めて整理してみようと思います。

この項は、歴史的なことにしか触れないので、興味のない方は読み飛ばしていただいて構いません。

k6はスウェーデンのLoad Impact社が2016年に開発を開始し、2017年2月にオープンソースとして公開したツールです。

[https://grafana.com/blog/grafana-k6-one-year-later-lessons-learned-after-an-acquisition/:embed:cite]

[https://x.com/gr1m0h/status/2006999387650797895:embed:cite]

以前のLoad Impact社が提供するLoad ImpactというSaaSでは、スクリプト言語としてLuaを使用していました。Load Impactの開発者ブログによると、LuaJIT VMは非常に高速でリソース効率が良く、限られたハードウェアで多くの仮想ユーザーをシミュレートできるため、負荷テストツールには適した選択だったとのことです。しかし、Luaは当時まだマイナーな言語であり、多くの開発者にとって馴染みがないという課題がありました。そこで、より多くの開発者が使いやすいJavaScriptを採用した新しいツールとしてk6が開発されました。つまり、k6自体は最初からJavaScriptベースで設計されており、k6でLuaを使うことはできません。

[https://web.archive.org/web/20240314164107/https://k6.io/blog/creating-k6/:embed:cite]

私が利用していた当時は、CLIツールとしてのk6と、クラウドサービスとしての「Load Impact」「Load Impact Insights」という構成でした。Load Impactはk6のスクリプトをクラウド上で分散実行でき、Load Impact Insightsで結果を可視化・分析できるサービスでした。当時はLuaベースのLoad Impact v3も並行して提供されており、LuaからJavaScriptへの移行ガイドも用意されていました。

当時のk6ドキュメントサイトは ReadMe を使用してホスティングされており、私もここにコントリビュートしていました。

[https://readme.com/:embed:cite]

2020年2月24日、Load Impact社は製品・ブランド名を「k6」にリブランディングし、クラウドサービスも「k6 Cloud」に名称変更しました。なお、法人名（Load Impact AB）は変更されていません。これは会社名の変更ではなく、あくまで製品・ブランド名のリブランディングです。

[https://community.grafana.com/t/load-impact-is-now-k6/95571:embed:cite]

そして2021年6月17日、GrafanaCONline 2021の最終日にGrafana LabsによるLoad Impact社の買収が発表されました。

[https://grafana.com/about/press/2021/06/17/grafana-labs-brings-modern-open-source-load-testing-to-observability-with-acquisition-of-k6/:embed:cite]

[https://www.globenewswire.com/en/news-release/2021/06/17/2249273/0/en/Grafana-Labs-Brings-Modern-Open-Source-Load-Testing-to-Observability-with-Acquisition-of-k6.html:embed:cite]

その後、k6 CloudはGrafana Cloudに統合され、現在は「Grafana Cloud k6」として提供されています。OSSとしてのk6の開発方針は変わらず、Grafanaのオブザーバビリティスタックとの統合が進み、より強力なツールへと進化しています。

[https://grafana.com/products/cloud/k6/:embed:cite]

2025年5月7日、GrafanaCON 2025にてk6 1.0の一般提供開始（GA）が発表されました。約9年間の開発を経て、ネイティブTypeScriptサポート、セマンティックバージョニング、安定したAPIサーフェスなど、エンタープライズ利用に耐えうる成熟したツールとなりました。

[https://grafana.com/about/press/2025/05/07/grafana-labs-demonstrates-open-source-leadership-at-grafanacon-2025/:embed:cite]

[https://grafana.com/blog/2025/05/07/grafana-k6-1.0-release/:embed:cite]

## インストール

macOSではHomebrewを使用してインストールできます。asdf-vmやmiseも使用可能です。

```bash
# Homebrew
brew install k6
# asdf-vm
asdf plugin add k6
asdf install k6 latest
# mise
mise use -g k6@latest
```

ちなみにasdf-vmやmiseが内部で利用しているk6用のasdf-pluginは私が作成したものです。

[https://github.com/gr1m0h/asdf-k6:embed:cite]

2019年に作成したこのプラグインが今でも使われているのは嬉しい限りです。

## テストスクリプトの作成

`k6 new script.ts`でテンプレートを生成できます。k6 1.0からTypeScriptがネイティブサポートされ、トランスパイル不要で直接実行できるようになりました。個人的には、この変更が1.0で最も嬉しいアップデートだと感じています。

型定義をインストールしておくとIDEの補完が効きます。

```bash
npm install --save-dev @types/k6
```

テストスクリプトの基本構造は以下のとおりです。

```typescript
import http, { Response } from "k6/http";
import { check, sleep } from "k6";
import { Options } from "k6/options";

// Test configuration
export const options: Options = {
  vus: 10,
  duration: "30s",
  thresholds: {
    http_req_duration: ["p(95)<500"],
    http_req_failed: ["rate<0.01"],
  },
};

// Test logic executed repeatedly by each VU
export default function (): void {
  const res: Response = http.get(
    "https://jsonplaceholder.typicode.com/todos/1",
  );
  check(res, {
    "status is 200": (r: Response): boolean => r.status === 200,
  });
  sleep(1);
}
```

## テストの実行

`k6 run script.ts`で実行します。実行結果には閾値の判定、チェックの成功率、レスポンスタイムの統計などが表示されます。

```bash
  █ THRESHOLDS
    http_req_duration
    ✓ 'p(95)<500' p(95)=77.37ms

  █ TOTAL RESULTS
    checks_succeeded...: 100.00% 574 out of 574
    http_req_duration..............: avg=56.88ms p(95)=77.37ms
    http_reqs......................: 287    9.403621/s
```

## 負荷のかけ方

k6では負荷のかけ方を柔軟に設定できます。ここでは代表的な3つのパターンを紹介します。

### 固定負荷

`vus`と`duration`で固定負荷を指定する方法です。

```typescript
export const options: Options = {
  vus: 10,
  duration: "30s",
};
```

### 段階的負荷

実際のユーザーアクセスに近い負荷パターンをシミュレートするには、`stages`オプションを使用します。

```javascript
export const options = {
  stages: [
    { duration: "30s", target: 20 }, // Ramp up to 20 VUs over 30 seconds
    { duration: "1m", target: 20 }, // Stay at 20 VUs for 1 minute
    { duration: "30s", target: 0 }, // Ramp down to 0 VUs over 30 seconds
  ],
};
```

この設定により、ウォームアップ、定常状態、クールダウンという典型的な負荷パターンを再現できます。

### シナリオ

より複雑な負荷パターンには`scenarios`オプションを使用します。シナリオを使うと、複数の負荷テストパターンを1つのスクリプトで管理できます。

```javascript
export const options = {
  scenarios: {
    // Send requests at a constant rate
    constant_request_rate: {
      executor: "constant-arrival-rate",
      rate: 100,
      timeUnit: "1s",
      duration: "1m",
      preAllocatedVUs: 50,
    },
    // Gradually increase VUs
    ramping_vus: {
      executor: "ramping-vus",
      startVUs: 0,
      stages: [
        { duration: "30s", target: 50 },
        { duration: "1m", target: 50 },
        { duration: "30s", target: 0 },
      ],
    },
  },
};
```

k6には複数のエグゼキューターが用意されており、目的に応じて選択できます。

[https://grafana.com/docs/k6/latest/using-k6/scenarios/executors/:embed:cite]

## 閾値の設定

テストの合否判定には`thresholds`オプションを使用します。

```javascript
export const options = {
  thresholds: {
    http_req_duration: ["p(95)<500"], // 95th percentile under 500ms
    http_req_failed: ["rate<0.01"], // Error rate under 1%
  },
};
```

閾値を満たさない場合、k6は0以外の終了コードで終了します。CI/CDパイプラインに組み込む際に便利です。

[https://pkg.go.dev/go.k6.io/k6/errext/exitcodes:embed:cite]

複数の条件を設定することもできます。

```javascript
export const options = {
  thresholds: {
    http_req_duration: [
      "p(95)<500", // 95th percentile under 500ms
      "p(99)<1000", // 99th percentile under 1000ms
      "avg<300", // Average under 300ms
    ],
    http_req_failed: ["rate<0.01"],
  },
};
```

## チェックとグループ

`check`でレスポンスを検証し、`group`で関連するリクエストをまとめます。チェックは閾値と異なり、失敗してもテストは継続します。

```typescript
import http from "k6/http";
import { check, group } from "k6";

export default function () {
  group("API Tests", function () {
    const res = http.get("https://quickpizza.grafana.com");
    check(res, {
      "status is 200": (r) => r.status === 200,
      "response time < 500ms": (r) => r.timings.duration < 500,
    });
  });
}
```

ここで疑問に思うのは、「閾値とチェックの使い分けはどうすればよいか」ということです。個人的には、テスト全体の合否判定には閾値を使い、個別のレスポンス検証にはチェックを使うようにしています。チェックはあくまで「確認」であり、失敗してもテストは続行されるため、デバッグや詳細な検証に向いていると思います。

## テストライフサイクル

k6のテストには4つのフェーズがあります。

```javascript
import http from "k6/http";

// 1. init: Runs once per VU at startup
const BASE_URL = "https://jsonplaceholder.typicode.com";

// 2. setup: Runs once before the test starts
export function setup() {
  // Fetch existing data to determine the target ID for testing
  const res = http.get(`${BASE_URL}/posts/1`);
  return { postId: res.json("id") };
}

// 3. default: Runs repeatedly by each VU (main test logic)
export default function (data) {
  http.get(`${BASE_URL}/posts/${data.postId}`);
}

// 4. teardown: Runs once after the test ends
export function teardown(data) {
  console.log("Test completed with postId:", data.postId);
}
```

`setup`で取得したデータは、`default`と`teardown`に引数として渡されます。認証トークンの取得やテストデータの準備などに使えます。

## 結果の可視化

### Web Dashboard

k6には組み込みのWebダッシュボードがあります。以下のコマンドで有効化できます。

```bash
k6 run --out web-dashboard script.js
```

テスト中に`http://localhost:5665`にアクセスすると、リアルタイムで結果を確認できます。

### JSON/CSV出力

結果をファイルに出力することもできます。

```bash
# JSON format
k6 run --out json=results.json script.js

# CSV format
k6 run --out csv=results.csv script.js

# Summary in JSON format
k6 run --summary-export=summary.json script.js
```

## 環境変数

`__ENV`で環境変数にアクセスできます。環境ごとに設定を切り替える際に便利です。

```typescript
const BASE_URL = __ENV.BASE_URL || "https://quickpizza.grafana.com";
const API_KEY = __ENV.API_KEY;

export default function () {
  const res = http.get(`${BASE_URL}/api/pizza`, {
    headers: { Authorization: `Bearer ${API_KEY}` },
  });
}
```

```bash
BASE_URL=https://quickpizza.grafana.com API_KEY=xxx k6 run script.ts
# Or use the -e flag
k6 run -e BASE_URL=https://quickpizza.grafana.com script.ts
```

## カスタムメトリクス

組み込みメトリクス以外に、独自のメトリクスを定義することもできます。

```typescript
import http from "k6/http";
import { Counter, Trend, Rate, Gauge } from "k6/metrics";

// Custom metrics definition
const apiCalls = new Counter("api_calls");
const apiDuration = new Trend("api_duration");
const apiSuccess = new Rate("api_success");
const activeUsers = new Gauge("active_users");

export default function () {
  const res = http.get("https://quickpizza.grafana.com");

  apiCalls.add(1);
  apiDuration.add(res.timings.duration);
  apiSuccess.add(res.status === 200);
  activeUsers.add(10);
}
```

| 型        | 用途                           |
| --------- | ------------------------------ |
| `Counter` | 累積値（リクエスト数など）     |
| `Trend`   | 統計値（レスポンスタイムなど） |
| `Rate`    | 割合（成功率など）             |
| `Gauge`   | 瞬間値（同時接続数など）       |

## 複数ファイルでのテスト分割

これまでは1つのファイルでテストを記述してきましたが、実際のプロジェクトではテストが大きくなることも多いと思います。テストが大きくなったら、モジュールに分割して管理します。

```
tests/
├── config/
│   └── options.ts
├── utils/
│   └── helpers.ts
├── scenarios/
│   ├── login.ts
│   └── checkout.ts
└── main.ts
```

```typescript
// config/options.ts
import { Options } from "k6/options";

export const options: Options = {
  vus: 10,
  duration: "30s",
};
```

```typescript
// scenarios/login.ts
import http from "k6/http";
import { check } from "k6";

export function login(baseUrl: string, username: string, password: string) {
  const payload = JSON.stringify({ username, password });
  const params = { headers: { "Content-Type": "application/json" } };
  const res = http.post(`${baseUrl}/posts`, payload, params);
  check(res, { "login success": (r) => r.status === 201 });
  // Return token for actual login API
  const body = res.json();
  return body?.id ? `mock-token-${body.id}` : null;
}
```

```typescript
// main.ts
import { options } from "./config/options.ts";
import { login } from "./scenarios/login.ts";

export { options };

const BASE_URL = __ENV.BASE_URL || "https://jsonplaceholder.typicode.com";

export default function () {
  const token = login(BASE_URL, "user", "pass");
  // Subsequent processing...
}
```

## さいごに

k6の基本的な使い方を紹介しました。k6 1.0でTypeScriptのネイティブサポートやセマンティックバージョニングへの準拠が入り、安定した開発体験が得られるようになっています。

本記事ではk6単体での使い方を中心に紹介しましたが、実際の運用ではGrafana Cloud k6との連携やCI/CDパイプラインへの組み込みも重要になってきます。これらについては、形になったタイミングで別途まとめられればと思います。

その他k6の詳細については公式ドキュメントを参照ください。

[https://grafana.com/docs/k6/latest/:embed:cite]

[https://github.com/grafana/k6:embed:cite]
